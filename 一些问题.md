# 一些问题

## MySQL

1. REDO生成到最终落盘的完整过程？(包括REDO内容的产生，REDO写入InnoDB Log Buffer，从InnoDB Log Buffer写入操作系统Page Cache，以及REDO刷盘，之后还需要唤醒等待的用户线程完成Commit。[来自这里](http://catkang.github.io/2020/02/27/mysql-redo.html))

   * 对于事务来说，commit即可认为事务已提交(已经持久化到硬盘)；但是对于redo log来说，该事务所有操作产生的redo log以及committed标志都刷盘，才可以认为事务已经提交

   * 分清 WAL(write ahead log)的作用对象和 steal & no-force的作用对象--->是日志还是数据

     WAL：日志刷盘要先于对应的数据页刷盘；事务提交时要将所有对应的日志刷盘

     Steal&No-Force：未提交的脏数据页可以提前刷盘，已提交的脏数据页可以不强制刷盘

2. Redo Log的刷盘策略？



## 计算机网络

1. ping的工作原理 (ICMP & ARP?)
2. 有了 IP 地址，为什么还要用 MAC 地址？([来自这里](https://www.zhihu.com/question/21546408))



## Redis

1. 数据结构

   * sds的embstr编码与缓存行的关系？([来自这里](https://zhuanlan.zhihu.com/p/43776747))

     - 16个字节的robj结构。([来自这里](http://zhangtielei.com/posts/blog-redis-robj.html))
     - 3个字节的sdshdr8头。
     - 最多44个字节的sds字符数组。
     - 1个NULL结束符。

     embstr编码的string最长64字节，刚好能放进一个cache line

   * Redis为什么用skiplist而不是平衡树？InnoDB的索引为什么用B+ tree而不是skiplist？

     * 第一个问题：skiplist和balance tree的内部元素都是有序的，都适合做范围查找。

       1. 但是对平衡树来说相对复杂，找到左边界后还需要以中序遍历找到右边界；对skiplist来说，找到最小值后直接对第一层的链表遍历即可。
       2. 对于元素的插入和删除来说，平衡树可能需要对进行旋转操作；对skiplist来说，只需要修改相邻节点的指针即可
       3. 从实现难度上来说，skiplist要简单的多

     * 第二个问题：

       从本质来说，Redis和MySQL面向的存储介质不同，MySQL用磁盘来存储数据，其增删改查的耗时主要来自于I/O时间。B+ tree的非叶子节点只会存储索引键从而扇出更多的节点，使得树的高度更低，整体更加“矮胖”；若用skiplist做索引，越往后的节点需要更多的I/O不说，每次两个节点之间的键值比较可能也需要先读取页面再作比较。