# synchronized

## 应用

## 锁升级

针对不同的并发场景(锁竞争的激烈程度)来优化锁的获取与释放

### 无锁

### 偏向锁

* 设想的场景：只有一个线程进入临界区

* 锁的获取

  检查 Mark Word 是否为可偏向状态，若为可偏向状态，检查 Mark Word 的线程ID是否为当前线程ID，如果是，则获取成功；如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则说明当前存在多线程竞争的情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块

* 锁的释放

  偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。

* 偏向锁的撤销

  1. 暂停持有偏向锁的线程
  2. 判断对象是否处于锁定状态，如果不是，则恢复为无锁状态；否则挂起线程，升级为轻量级锁(Mark Word 设置为指向 Lock Record 的指针，然后恢复线程)

### 轻量级锁

通过使用CAS，来减少对操作系统 Mutex Lock 和 阻塞唤醒 系统调用的使用，以减少获取锁和释放锁的开销

* 设想的场景：多个线程交替进入临界区(允许一定次数的自旋失败)
* 锁的获取：JVM在当前线程的栈帧中创建一个 Lock Record空间，将Mark Word复制到Lock Record中，然后通过CAS将Mark Word设置为指向当前线程栈帧的指针，如果成功则获取到锁；如果失败，则会检查Mark Word 是否指向当前线程的栈帧如果是则说明已经获取锁；否则说明存在线程竞争且自旋超过阈值，升级为重量级锁
* 锁的释放：通过CAS将Mark Word还原，如果成功则锁释放；如果失败，则此时已经膨胀为重量级锁，释放锁的同时还会唤醒阻塞的线程

***

关于CAS的开销

CAS(compare and swap)实际上是对复合操作的原子指令，其作用是让CPU比较后原子地更新某个位置的值。对于对称多处理器架构来说，一个CPU有多个核心，每个核心都有独享的L1、L2 cache 和 所有核心共享的L3 cache，根据局部性原理，CPU会缓存最近的数据和指令，多个CPU对共享变量的修改涉及缓存一致性问题，修改的同时通过总线通知其他核心缓存失效，如果频繁使用CAS

* 一是会导致总线风暴，总线的带宽就会成为性能的瓶颈
* 二是无法很好的利用多层存储架构，速度变慢(可能相当于L1、L2 cache不存在)

### 重量级锁

* 设想的场景：多个线程同时进入临界区
* 锁的获取：通过CAS将ObjectMonitor的owner设置为当前线程，如果成功则获取成功，进入临界区；如果失败，会把当前线程封装成一个节点，通过CAS加入同步队列，然后调用park阻塞当前线程
* 锁的释放：执行完临界区的代码，unpark唤醒处于同步队列里的线程

***

重量级锁为何重量级？

一是机制比较复杂，重量级锁实际上是按照 **管程Monitor** 的思想实现的一种并发机制，由Mutex Lock、同步队列、等待队列等组件组成，涉及阻塞唤醒机制

二是等待唤醒比较耗时，从操作系统的角度来说，Mutex Lock 和 park() 都是系统调用syscall，前者会有用户态和内核态的转换，后者在此基础上还会有进程的切换。以 park() 为例，调用syscall会先发生模式切换，由用户态陷入内核态(Trap)，模式切换并不会改变线程/进程的执行状态，只需要保存部分寄存器然后在内核栈上进行函数调用；阻塞的时候会发生进程的上下文切换，

* 修改当前进程的PCB状态，保存上下文，加入对应的进程队列
* CPU调度器从就绪队列中取出新进程，加载上下文，更新其PCB
* 更新页表，刷新块表，缓存失效

***

Object.wait() and notify()

它与jdk里的条件变量Condition 的await() 和 signal()类似，都是sleep&wake up睡眠唤醒机制的套路。

wait会先释放当前线程的锁，然后封装为节点加入等待队列；notify会唤醒位于等待队列的节点，将其加入同步队列，但是线程并不会立即从wait返回，仍需要尝试去获取对象锁，然后才能从wait返回

## 与Lock比较

